#include <stdio.h>
#include <stdlib.h>
#define min(a, b) ((a) <= (b) ? (a) : (b))
int main()
{
    // в данном алгоритме используется ополовиненный массив количества возможных разложений по убыванию по старшим членам с исключением повторения
    //+- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --------------------------------->ось j
    //|     (1)(2)(3)(4)(5)(6)(7)(8)(9)(10)
    //|      0  1  2  3  4  5  6  7  8  9
    //|     +-------------------------------
    //|(1) 0|1
    //|(2) 1|1  1
    //|(3) 2|1  1  1
    //|(4) 3|1  2  1  1
    //|(5) 4|1  2  2  1  1
    //|(6) 5|1  3  3  2  1  1
    //|(7) 6|1  3  4  3  2  1  1
    //|(8) 7|1  4  5  5  3  2  1  1
    //|(9) 8|1  4  7  6  5  3  2  1  1
    //|(10)9|1  5  8  9  7  5  3  2  1  1
    //|
    //|
    //|
    //|
    //|
    //|
    //о
    //с
    //ь
    //получаем полурекурсивный алгоритм с оптимальным отношением занимаемая память/необходимое время


    int a[100][100] = {{0}}, n, i, j, k;
    a[0][0] = 1;
    scanf("%d", &n);
    for(i = 1; i < n; i++)
    {
        a[i][0] = 1;
        a[i][i] = 1;
        for (j = i - 1; j > 0; --j)
        {
            for(k = min((i - j - 1), j); k >= 0; k--)
            {
                a[i][j] += a[i - j - 1][k];
            }

        }
    }
    for (i = 0; i < n; i++)
    {
        a[0][1] += a[n-1][i];
    }
    printf("%d\n", a[0][1]);
    return 0;
}
